## 动态规划

DP算法把原问题视作若干个**重叠子问题**的逐层递进，每个子问题的求解过程都构成一个<u>阶段</u>。在完成前一个阶段的计算后，动态规划才会执行下一阶段的计算。

> 重叠子问题：子问题与原问题的计算步骤一样，且在计算原问题时需要多次重复计算子问题。

为了保证计算能够按顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响，即**无后效性**（动态规划对<u>状态</u>空间的遍历构成一张有向无环图，遍历顺序就是该有向无环图的一个拓扑序，而边的选择就是动态规划中的<u>决策</u>）。

> *自底向上* 的动态规划算法是按 *逆拓扑序* 来处理子问题图中的顶点。对于任何子问题，直至它依赖的所有子问题均已求解完成才会求解它。因此这种方法需要恰当定义子问题的“规模”，使得任何子问题的求解都只依赖于更小的子问题的求解。
>
> *带备忘的自顶向下* 的动态规划算法相当于在子问题图中进行深度优先搜索。此方法仍按自然的递归形式编写过程，但过程中会保存每个子问题的解。
>
> 通常情况下，如果每个子问题都必须求解，自底向上的方法会更快，因为其没有递归调用的开销，表的维护开销也更小。但若一些子问题没有求解的必要时，自顶向下的方法更占优势，因为它只会求解绝对必要的子问题，

动态规划在阶段计算完成时，只会在每个状态上保留与最终解集相关的部分代表信息，代表信息应具有 *可重复的求解过程* ，并能够导出后续阶段的代表信息。体现在优化问题中即是**最优子结构性质**。

> 最优子结构: 动态规划常用于求解最优化问题，问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。


动态规划算法把相同的计算过程作用于各阶段的同类子问题，这个计算过程即为 *状态转移方程* 。

解决步骤：

* 刻画一个最优解的结构特征；
* 递归地定义最优解的值；
* 计算最优解的值；
* 利用计算出的信息构造一个最优解。



多阶段决策最优解：在解决问题的过程中，需要经过多个决策<u>阶段</u>，每个决策阶段对应一组<u>状态</u>，寻找能够产生最优值的<u>决策</u>序列。

> 同样是解决多阶段决策最优解问题，回溯算法相当于穷举搜索，复杂度在指数级别；动态规划比回溯算法高效，但必须满足最优子结构、无后效性和重叠子问题这三个特征才能使用；贪心算法相当于动态规划的一种特殊情况，效率更高，在要求满足最优子结构和无后效性之外，需要满足贪心选择性——通过局部最优的选择能产生全局最优的结果。

> 分治法与动态规划相比，是将原问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来求原问题的解。适合用分治方法求解的问题通常在递归的每一步都生成全新的子问题，而不是求解重叠子问题。


### 线性DP

除了线性时间复杂度的一维DP外，如果一个动态规划算法的“状态”包含多个维度，但在每个维度上都具有“线性”变化的阶段，那么该动态规划算法就被称为线性DP。

这类问题中，需要计算的对象表现出明显的维度以及有序性，每个状态的求解直接构成一个阶段，使得**DP的状态表示就是阶段的表示**。在每个维度上各取一个坐标值作为DP的状态，自然就可以描绘出“已求解部分”在状态空间中的轮廓特征。按顺序依次循环每个维度，根据问题要求递推求解即可。



#### 300. 最长递增子序列   LIS

* 动态规划。dp[i]表示以nums[i]结尾的最长递增子序列的长度。dp[i]既代表以i结尾的状态，同时也是子问题求解的一个阶段。O(n^2)

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1]*n
        for i in range(1,n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

* 贪心+二分。单调栈保存现在发现的上升子序列，为了使子序列尽可能的长，需要寻找尽可能小的值放到序列末尾。O(nlogn)

```python
class Solution(object):
    def lengthOfLIS(self, nums):
        seq = []
        for each in nums:
            if not seq or each > seq[-1]:
                seq.append(each)
            else:
            	# 替换掉当前子序列中的较大值,子序列长度不变
                l, r = 0, len(seq)-1
                while l <= r:
                    mid = (l+r)//2
                    if seq[mid] < each:
                        l = mid + 1
                    else:
                        r = mid - 1
                seq[l] = each  # seq中大于等于each的最小值 
        return len(seq)
```

#### 354. 俄罗斯套娃信封问题	LIS

* 动态规划。排序后转化为最长（高度）递增子序列。

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        n = len(envelopes)
        # 根据宽度递增，宽度相同时根据高度递减
        envelopes.sort(key=lambda x: (x[0],-x[1]))
        dp = [1] * n
        for i in range(1,n):
            for j in range(i):
                if envelopes[j][1]<envelopes[i][1]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

* 贪心+二分。

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        n = len(envelopes)
        envelopes.sort(key=lambda x: (x[0],-x[1]))
        stack = []
        for _,h in envelopes:
            if not stack or stack[-1]<h:
                stack.append(h)
            else:
                l, r = 0, len(stack)-1
                while l <= r:
                    mid = (l+r)//2
                    if stack[mid]<h:
                        l = mid + 1
                    else:
                        r = mid - 1
                stack[l] = h
        return len(stack)
```

#### 1143. 最长公共子序列	LCS

* dp\[i][j]表示text1的前i项和text2的前j项的最长公共子序列的长度。

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0]*(n+1) for _ in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        return dp[-1][-1]
```

#### 120. 三角形最小路径和

* dp\[i][j]表示走到第i行第j列的最小路径和。

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        dp = [0]+[float('inf')] * n
        for i in range(n):
            for j in range(i,-1,-1):
                dp[j] = min(dp[j],dp[j-1])+triangle[i][j]
        return min(dp)
```

#### 53. 最大子序和

* dp[i]表示以i结尾的最大子序和。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0] * n
        for i in range(n):
            dp[i] = max(nums[i],nums[i]+dp[i-1])
        return max(dp)
```

* 前缀和

```python
class Solution(object):
    def maxSubArray(self, nums):
        sums = mins = 0
        res = float('-inf')
        for each in nums:
            sums += each
            res = max(res, sums-mins)
            mins = min(mins, sums)
        return res
```

* 贪心，当前子序和为负数时，重新计算。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = nums[0]
        cur = 0
        for each in nums:
            cur = each if cur <= 0 else cur+each
            res = max(res,cur)
        return res
```

#### 152. 乘积最大子数组

* dp[i]记录以i结尾的子数组乘积最大值和最小值。

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[nums[i]]*2 for i in range(n)]
        for i in range(1,n):
            if nums[i] >= 0:
                dp[i][0] = max(nums[i],dp[i-1][0]*nums[i])
                dp[i][1] = min(nums[i],dp[i-1][1]*nums[i])
            else:
                dp[i][0] = max(nums[i],dp[i-1][1]*nums[i])
                dp[i][1] = min(nums[i],dp[i-1][0]*nums[i])
        return max(dp[i][0] for i in range(n))
    
# 优化空间
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        min_ = max_ = res = nums[0]
        for i in range(1,len(nums)):
            if nums[i] >=0:
                max_, min_ = max(max_*nums[i],nums[i]),min(min_*nums[i],nums[i])
            else:
                max_, min_ = max(min_*nums[i],nums[i]),min(max_*nums[i],nums[i])
            res = max(res,max_)
        return res
```

#### 887. 鸡蛋掉落

> 鸡蛋越多操作数才可能减少，要不然只能逐层尝试。分类讨论从每层扔下鸡蛋摔碎或完好的情况，因为要考虑最坏情况，所以需要选择合适的楼层使两种情况的最大值最小。

* dp\[i][j]表示i层楼，j个鸡蛋的最小操作次数。

  * 不使用第j个鸡蛋：$dp[i][j-1]$

  * 使用第j个鸡蛋，在第x层扔下，选择二者中的较大值也就是最坏情况：

    * 蛋碎，搜索空间变成1~x-1，$dp[x-1][j-1]$
    * 未碎，搜索空间变成x+1~i，$dp[i-x][j]$

    枚举楼层x，找到最小的操作次数

```python
```

